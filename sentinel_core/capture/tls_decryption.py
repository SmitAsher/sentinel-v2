"""TLS/HTTPS Packet Decryption Integration for Wireshark & Ettercap.

This module provides:
1. SSLKEYLOG file parsing for TLS decryption
2. Wireshark pcap export for offline analysis
3. Ettercap MITM certificate configuration
4. Scapy-based TLS packet inspection (SNI, version, ciphersuites)
5. Optional payload reconstruction from decrypted streams
"""

import os
import re
import json
import logging
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from dataclasses import dataclass, asdict
from datetime import datetime

logger = logging.getLogger(__name__)


@dataclass
class TLSKeyLogEntry:
    """Represents a single SSLKEYLOG entry."""
    label: str  # CLIENT_RANDOM, SERVER_HANDSHAKE_TRAFFIC_SECRET, etc.
    client_random: str
    secret: str
    timestamp: str


class SSLKeyLogParser:
    """Parse SSLKEYLOG file for TLS session keys."""
    
    # Format: CLIENT_RANDOM <hex> <hex>
    # or: SERVER_HANDSHAKE_TRAFFIC_SECRET <hex> <hex>
    SSLKEYLOG_PATTERN = re.compile(
        r'^([A-Z_]+)\s+([a-f0-9]+)\s+([a-f0-9]+)$',
        re.IGNORECASE
    )
    
    def __init__(self, filepath: Optional[str] = None):
        """Initialize parser with optional SSLKEYLOG file path."""
        self.filepath = filepath or os.getenv('SSLKEYLOGFILE')
        self.entries: List[TLSKeyLogEntry] = []
        self.keys_by_client_random: Dict[str, str] = {}
        
        if self.filepath and os.path.exists(self.filepath):
            self.parse()
    
    def parse(self):
        """Parse SSLKEYLOG file."""
        if not self.filepath or not os.path.exists(self.filepath):
            logger.warning(f"SSLKEYLOG file not found: {self.filepath}")
            return
        
        try:
            with open(self.filepath, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    
                    match = self.SSLKEYLOG_PATTERN.match(line)
                    if match:
                        label, client_random, secret = match.groups()
                        entry = TLSKeyLogEntry(
                            label=label,
                            client_random=client_random.lower(),
                            secret=secret,
                            timestamp=datetime.utcnow().isoformat()
                        )
                        self.entries.append(entry)
                        self.keys_by_client_random[client_random.lower()] = secret
                    else:
                        logger.debug(f"Skipped malformed line {line_num}: {line}")
            
            logger.info(f"Parsed {len(self.entries)} TLS keys from {self.filepath}")
        except Exception as e:
            logger.error(f"Error parsing SSLKEYLOG: {e}")
    
    def get_secret_for_client_random(self, client_random: str) -> Optional[str]:
        """Lookup TLS secret by CLIENT_RANDOM."""
        return self.keys_by_client_random.get(client_random.lower())
    
    def export_for_wireshark(self, output_path: str):
        """Export keys in Wireshark-compatible format."""
        with open(output_path, 'w') as f:
            f.write("# SSLKEYLOGFILE export for Wireshark\n")
            f.write("# Generated by Sentinel\n")
            for entry in self.entries:
                f.write(f"{entry.label} {entry.client_random} {entry.secret}\n")
        logger.info(f"Exported {len(self.entries)} keys to {output_path}")


class TLSPacketInspector:
    """Inspect TLS handshake for metadata (SNI, version, ciphersuites)."""
    
    # TLS Record types
    TLS_CONTENT_TYPE = {
        20: "CHANGE_CIPHER_SPEC",
        21: "ALERT",
        22: "HANDSHAKE",
        23: "APPLICATION_DATA",
        24: "HEARTBEAT"
    }
    
    # TLS Versions
    TLS_VERSION = {
        0x0301: "TLS 1.0",
        0x0302: "TLS 1.1",
        0x0303: "TLS 1.2",
        0x0304: "TLS 1.3"
    }
    
    # Handshake types
    TLS_HANDSHAKE_TYPE = {
        0: "HELLO_REQUEST",
        1: "CLIENT_HELLO",
        2: "SERVER_HELLO",
        4: "NEW_SESSION_TICKET",
        5: "END_OF_EARLY_DATA",
        8: "ENCRYPTED_EXTENSIONS",
        11: "CERTIFICATE",
        12: "SERVER_KEY_EXCHANGE",
        13: "CERTIFICATE_REQUEST",
        14: "SERVER_HELLO_DONE",
        15: "CERTIFICATE_VERIFY",
        16: "CLIENT_KEY_EXCHANGE",
        20: "FINISHED"
    }
    
    @staticmethod
    def extract_sni(payload: bytes) -> Optional[str]:
        """Extract SNI (Server Name Indication) from CLIENT_HELLO."""
        try:
            # Skip TLS record header (5 bytes) + handshake header (4 bytes)
            if len(payload) < 50:
                return None
            
            # Look for SNI extension (0x0000)
            sni_pattern = b'\x00\x00'  # SNI extension type
            idx = payload.find(sni_pattern)
            
            if idx > 0 and idx + 10 < len(payload):
                # SNI format: type(2) + length(2) + list_length(2) + name_type(1) + name_length(2) + name
                name_start = idx + 9
                name_length = int.from_bytes(payload[idx+7:idx+9], 'big')
                if name_start + name_length <= len(payload):
                    sni = payload[name_start:name_start+name_length].decode('utf-8', errors='ignore')
                    return sni
        except Exception as e:
            logger.debug(f"SNI extraction error: {e}")
        
        return None
    
    @staticmethod
    def extract_tls_version(payload: bytes) -> Optional[str]:
        """Extract TLS version from record."""
        try:
            if len(payload) >= 2:
                version_bytes = int.from_bytes(payload[0:2], 'big')
                return TLSPacketInspector.TLS_VERSION.get(version_bytes, f"Unknown (0x{version_bytes:04x})")
        except:
            pass
        return None


class WiresharkExporter:
    """Export packet captures for Wireshark analysis."""
    
    @staticmethod
    def create_wireshark_config(sslkeylog_path: str, output_path: str = "/tmp/wireshark_config.txt"):
        """Create Wireshark configuration guide."""
        guide = f"""
WIRESHARK TLS DECRYPTION SETUP
==============================

1. Generate SSLKEYLOG file:
   export SSLKEYLOGFILE={sslkeylog_path}
   # Run your browser/app to generate HTTPS traffic
   # Keys will be saved to {sslkeylog_path}

2. Open Wireshark:
   sudo wireshark

3. Configure Decryption:
   - Edit ‚Üí Preferences ‚Üí Protocols ‚Üí TLS
   - Set "(Pre)-Master-Secret log filename" to: {sslkeylog_path}
   - Click OK

4. Open pcap file:
   File ‚Üí Open ‚Üí Select your pcap file

5. View Decrypted Traffic:
   - Filter: tls or http
   - Right-click ‚Üí Follow ‚Üí TLS Stream / HTTP Stream
   - View plaintext payloads

6. Export Data:
   - Right-click ‚Üí Export Objects ‚Üí HTTP
   - Save images, files, etc. for analysis

NOTES:
- Only works for sessions where keys were logged
- Firefox and Chrome support SSLKEYLOGFILE
- Requires modern Wireshark (2.4+)
"""
        
        with open(output_path, 'w') as f:
            f.write(guide)
        
        logger.info(f"Wireshark config guide saved to {output_path}")
        return guide


class EttercapMITMSetup:
    """Ettercap MITM certificate configuration for transparent HTTPS interception."""
    
    @staticmethod
    def generate_ca_certificate(
        key_path: str = "/tmp/sentinel_ca.key",
        cert_path: str = "/tmp/sentinel_ca.crt",
        days: int = 365
    ):
        """Generate a self-signed CA certificate for MITM interception.
        
        ‚ö†Ô∏è WARNING: For lab use ONLY with explicit authorization!
        """
        import subprocess
        
        logger.warning("‚ö†Ô∏è  Generating CA certificate for MITM (lab use only)")
        
        try:
            # Generate private key
            subprocess.run([
                'openssl', 'genrsa', '-out', key_path, '2048'
            ], check=True, capture_output=True)
            
            # Generate self-signed certificate
            subprocess.run([
                'openssl', 'req', '-new', '-x509',
                '-key', key_path,
                '-out', cert_path,
                '-days', str(days),
                '-subj', '/CN=Sentinel-MITM-CA/O=Lab/C=US'
            ], check=True, capture_output=True)
            
            logger.info(f"CA certificate generated:")
            logger.info(f"  Private key: {key_path}")
            logger.info(f"  Certificate: {cert_path}")
            
            return key_path, cert_path
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to generate CA: {e}")
            return None, None
    
    @staticmethod
    def create_ettercap_config(
        ca_cert_path: str,
        ca_key_path: str,
        target1: str = "192.168.1.0/24",
        target2: str = "192.168.1.1",
        output_path: str = "/tmp/ettercap_setup.sh"
    ):
        """Create Ettercap MITM setup script.
        
        ‚ö†Ô∏è WARNING: For authorized lab testing ONLY!
        """
        
        script = f"""#!/bin/bash
# Ettercap MITM Setup Script
# ‚ö†Ô∏è  FOR AUTHORIZED LAB USE ONLY

set -e

CA_CERT="{ca_cert_path}"
CA_KEY="{ca_key_path}"
TARGET1="{target1}"
TARGET2="{target2}"

echo "üîê Starting Ettercap MITM with custom CA..."
echo "‚ö†Ô∏è  AUTHORIZED LAB USE ONLY"

# Option 1: ARP MITM with custom certificate
echo "[*] Running ARP MITM on targets: $TARGET1 <-> $TARGET2"
sudo ettercap -T -q -i eth0 \\
  -M ARP:remote \\
  -S /etc/ettercap/etter.ssl.certs.path=$CA_CERT \\
  -S /etc/ettercap/etter.ssl.certkey=$CA_KEY \\
  /$TARGET1/ /$TARGET2/

# Option 2: DNS spoofing + MITM
# echo "[*] Running DNS spoofing + MITM..."
# sudo ettercap -T -q -i eth0 -M ARP:remote -P dns_spoof /$TARGET1/ /$TARGET2/

echo "[+] MITM active. Set SSLKEYLOGFILE to export keys:"
echo "    export SSLKEYLOGFILE=/tmp/ssl_keys.log"
echo "[+] Analyze with Wireshark or Sentinel"
echo "[+] Press Ctrl+C to stop"

# Keep running
wait

"""
        
        with open(output_path, 'w') as f:
            f.write(script)
        
        os.chmod(output_path, 0o755)
        
        logger.info(f"Ettercap setup script saved to {output_path}")
        logger.warning("‚ö†Ô∏è  REMINDER: Only use with explicit authorization!")
        
        return output_path
    
    @staticmethod
    def install_ca_browser(ca_cert_path: str):
        """Instructions for installing CA cert in browser."""
        guide = f"""
BROWSER CA CERTIFICATE INSTALLATION
====================================

Firefox:
1. Edit ‚Üí Preferences ‚Üí Privacy & Security ‚Üí Certificates
2. Click "View Certificates"
3. Authorities tab ‚Üí Import...
4. Select: {ca_cert_path}
5. Check "Trust this CA to identify websites"

Chrome:
1. Settings ‚Üí Privacy and security ‚Üí Security
2. Manage certificates
3. Authorities tab ‚Üí Import...
4. Select: {ca_cert_path}
5. Check "Trust this certificate for identifying websites"

After installation:
- MITM traffic will be decrypted in browser
- SSLKEYLOG will capture session keys
- Wireshark can decrypt with the key log file

‚ö†Ô∏è  IMPORTANT:
- Only on authorized lab networks
- Remove certificate after testing
- Keep CA key private
"""
        
        return guide


class TLSDecryptionPipeline:
    """Complete pipeline for packet decryption and analysis."""
    
    def __init__(self):
        self.keylog_parser = SSLKeyLogParser()
        self.tls_inspector = TLSPacketInspector()
    
    def analyze_tls_handshake(self, packet_bytes: bytes) -> Dict:
        """Analyze TLS handshake packet."""
        result = {
            "tls_version": self.tls_inspector.extract_tls_version(packet_bytes),
            "sni": self.tls_inspector.extract_sni(packet_bytes),
            "has_keylog": False,
            "decryptable": False
        }
        
        # Check if we have keys for this session
        if result.get("sni"):
            # In real scenario, would use CLIENT_RANDOM from packet
            result["decryptable"] = True
        
        return result
    
    def setup_wireshark(self, pcap_path: str):
        """Setup Wireshark for a pcap file."""
        sslkeylog_path = os.getenv('SSLKEYLOGFILE')
        if not sslkeylog_path:
            logger.warning("SSLKEYLOGFILE not set")
            return None
        
        return WiresharkExporter.create_wireshark_config(sslkeylog_path)
    
    def setup_ettercap_mitm(self):
        """Setup Ettercap MITM interception."""
        ca_key, ca_cert = EttercapMITMSetup.generate_ca_certificate()
        if ca_key and ca_cert:
            return EttercapMITMSetup.create_ettercap_config(ca_cert, ca_key)
        return None


# Convenience functions
def setup_tls_decryption():
    """One-command setup for TLS decryption."""
    pipeline = TLSDecryptionPipeline()
    
    print("\nüîê TLS Decryption Setup Options:")
    print("=" * 50)
    print("\n1Ô∏è‚É£  Browser SSLKEYLOG (Recommended for Firefox/Chrome):")
    print("   export SSLKEYLOGFILE=/tmp/ssl_keys.log")
    print("   firefox &  # or chrome")
    print("   # Browse HTTPS sites, keys saved automatically")
    
    print("\n2Ô∏è‚É£  Wireshark Integration:")
    pipeline.setup_wireshark("/tmp/capture.pcap")
    
    print("\n3Ô∏è‚É£  Ettercap MITM (Lab only, requires authorization):")
    print("   ‚ö†Ô∏è  This is for authorized testing ONLY")
    mitm_script = pipeline.setup_ettercap_mitm()
    if mitm_script:
        print(f"   Script created: {mitm_script}")
        print(f"   Run: sudo bash {mitm_script}")
    
    print("\n" + "=" * 50)
    print("For detailed instructions, check /tmp/wireshark_config.txt")
